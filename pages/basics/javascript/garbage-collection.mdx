import gc_01 from './garbage-collection-01.png';
import gc_02 from './garbage-collection-02.png';
import gc_03 from './garbage-collection-03.png';
import Image from 'next/image';

# 垃圾回收

## 概念

自动垃圾回收是 JavaScript 的内存管理机制。垃圾回收器会定期清理不再需要的对象从而释放内存。
JS 主要的垃圾回收算法有：`引用计数法`和`标记-清除法`。

## 垃圾回收算法

### 引用计数算法

#### 工作原理

这是最初级的垃圾回收算法，其工作原理是跟踪记录每个对象被引用的次数，垃圾回收器会定期清理被引用次数为 0 的对象

#### 局限性

该算法有个限制，即无法处理循环引用的情况，两个对象相互引用，即使它们不再被使用，引用计数算法也会考虑到它们都有一次引用，从而不会被回收导致内存泄漏

### 标记-清除算法

#### 工作原理

`标记-清除算法`的工作原理是 JS 引擎定期采用深度优先搜索来进行可达性分析，从根对象开始递归地探索引用链，从而找到所有可以获得的对象。
在可达性分析之前，引擎会将所有对象添加清除标记，分析完之后去除可访问对象的清除标记，然后清除不可访问的对象。

到目前为止，所有浏览器都使用了标记-清除算法来进行垃圾回收，只是各大浏览器厂商对此算法进行了优化，并且 JS 引擎在垃圾回收的频率上有所差异

## V8 引擎的垃圾回收

### 概念

#### 回收机制

V8 引擎在`标记-清除算法`的基础上构建了其垃圾回收机制。V8 会将全局对象、DOM 树等特殊的活动对象称为 `GC Root`，垃圾回收器会从这些 `GC Root` 对象出发进行可达性分析从而清除无法被访问的对象。

#### 内存整理

通常，频繁回收对象后，内存中会出现大量不连续空间，这些不连续空间被称为`内存碎片`。V8 在垃圾回收之后会进行`内存整理`来消除内存碎片。

### 分区

V8 引擎会把堆分为`新生代`和`老生代`两个区域，新生代存放生存时间短的对象，老生代存放生存时间长的对象。
新生代的垃圾回收器称为`副垃圾回收器`，老生代的垃圾回收器称为`主垃圾回收器`

#### 新生代

新生代中的对象生存时间短，垃圾回收频繁，所以需要一个效率非常高的算法，副垃圾回收器采用`Scavenge算法`进行处理。

Scavenge 算法首先将新生代的存储空间分为两个空间：from 空间（对象区）和 to 空间（空闲区）。

<Image src={gc_01} width={657} height={377} />

新加入的对象会存放在对象区，当对象区域快被写满时，副垃圾回收器会对对象区域中的垃圾进行标记-清除。存活的对象会被复制到空闲区域中，同时回收器会把这些对象有序地排列起来从而完成内存整理。

完成复制后，对象区和空闲区会进行角色翻转，从而让这两块区域无限重复使用下去。

<Image src={gc_02} width={657} height={377} />

不过，副垃圾回收器每次执行清理操作时，都需要复制对象到空闲区，为了执行效率，新生区的空间会被设置得比较小。

**晋升策略**
如果对象之前已经经历过一次 Scavenge 回收或者空闲区已经被使用超过 25%，副垃圾回收器在复制阶段会将对象移动到老生代，即对象完成晋升。

#### 老生代

除了新生代中晋升的对象，一些大的对象会直接被分配到老生代中。老生代中的对象有两个特点：对象占用空间大、对象存活时间长。

Scavenge 算法会浪费一半空间，因此 Scavenge 算法并不适用于老生代空间，V8 在老生代中的垃圾回收是采用了`标记-清除(Mark-Sweep)`和`标记-整理(Mark - Compact)`两种算法相结合的方式进行的。

`标记-清除`算法会通过可达性分析标记活动对象，然后直接清除未被标记的对象，这部分对象通常在老生代中占比很小，所以标记-清除算法的效率较高。

多次执行`标记-清除`算法以后，内存碎片会越来越多，导致没有足够的连续内存分配给新进入老生代的对象。
此时主垃圾回收器通过`标记-整理`算法对活动对象进行标记，它不会直接清除可回收对象，而是让所有存活对象都向一端移动，然后清理掉这一端以外的内存

<Image src={gc_03} width={907} height={327} />

由于`标记-整理`算法需要移动对象，因此它的速度不会很快，V8 结合了`标记-清除`和`标记-整理`算法，主要采用`标记-清除`算法，如果空间不足的时候，才使用`标记-整理`。

### V8 垃圾回收的优化策略

#### 全停顿

最初，为了避免 js 逻辑和垃圾回收器看到的情况不一致的的情况，V8 采用了垃圾回收时将 js 执行暂停下来的方式，等待垃圾回收结束后才恢复 js 的执行，这种行为被成为全停顿（Stop-The-World）。

这种方式的劣势很明显，它会阻塞 js 的执行，如果垃圾回收占用的时间较长，就会造成页面明显的卡顿。为了解决全停顿的问题，V8 添加并行、增量、并发等技术对垃圾回收机制进行了优化。

#### 并行

并行是指主线程在执行垃圾回收的任务的同时，使用多个辅助线程来并行处理，这样就会加快垃圾回收的执行速度。

#### 增量

增量是指垃圾回收器每次只执行垃圾回收过程中的一小部分工作，主线程中 js 运行和垃圾回收交替执行，可以避免单次垃圾回收时间过长造成的卡顿问题。

#### 并发

并发是指在主线程不断执行 js 代码，开启其它辅助线程在后台执行垃圾回收

并行、增量、并发三种方式在 V8 的实际应用中不是单独存在的，V8 的主垃圾回收器融合了这三种机制。

主垃圾回收器采用辅助线程来进行并发标记，标记完成后主线程和辅助线程会进行并行清理，并且清理的任务会通过增量的方式穿插在 js 代码执行之间

## 开发启示

虽然浏览器可以进行垃圾自动回收，但是当代码比较复杂时，垃圾回收所带来的代价较大，因此在开发时可以通过代码习惯来减少一些垃圾回收：

- 对数组进行优化：在清空一个数组时，最简单的方法就是给其赋值为`[]`，但是与此同时会创建一个新的空对象，可以将数组的长度设置为 0，以此来达到清空数组的目的。
- 对 object 进行优化：对象尽量复用，对于不再使用的对象，就将其设置为 null，尽快被回收
