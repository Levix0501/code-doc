# 原型和原型链

## 原型链

### 概念

对象的构造函数的 `prototype` 属性和对象的 `__proto__` 属性指向同一个对象，称为原型对象，原型对象本身也有自己的原型对象，由此层层向上产生了一个链表称为原型链，其终点为 `Object.prototype` 对象，该对象的原型为 `null`

### 特点

1. 访问对象的属性或方法时，如果对象内部不存在，JS 引擎会沿着原型链向上查找，直到找到或到达原型链的终点
2. 原型链可以避免在每个对象上复制一份相同的属性和方法，从而节省内存

### 注意点

1. 在原型链上查找属性和方法比较耗时，对性能有副作用
2. 试图访问不存在的属性会遍历整个原型链
3. 如果原型链上的某个属性被修改了，那么继承自该原型的对象有可能会受到影响

### 应用场景

1. Vue 2 中使用 Vue.use 安装插件，比如 Vue.use(Router)，可以在全局使用 this.$router
2. 数组可以调用 Array.prototype 上的方法

### 拓展

1. `__proto__` 属性已从 ECMA 标准中移除
2. 遵循 ECMAScript 标准，符号 `someObject.[[Prototype]]` 用于标识 someObject 的原型
3. 可以通过 `Object.getPrototypeOf()` 来获取对象的原型

## instanceof 运算符

### 概念

`instanceof` 运算符用于检测右侧构造函数的原型对象是否出现在左侧对象的原型链上

### 注意点

如果原型链很深，查询效率会较低

### 拓展

- `instanceof` 的左侧只能是对象，不能是基本类型数据

#### 手写 instanceof

通过 `Object.getPrototypeof()` 获取对象的原型，遍历原型链，判断右侧构造函数的原型对象是否出现在原型链上

```js
const myInstanceof = (left, right) => {
  const prototype = right.prototype;
  let proto = Object.getPrototypeOf(left);
  while (proto) {
    if (proto === prototype) return true;
    proto = Object.getPrototypeOf(proto);
  }
  return false;
};
```

## new 运算符

### 概念

`new` 运算符用于创建用户定义的对象类型的实例或具有构造函数的内置对象的实例

### 中间过程

当使用 new 调用函数时，该函数将被当作构造函数。new 将执行以下操作：

1. 创建一个空的简单 JS 对象 `newInstance`，其 `[[prototype]]` 指向 `Object.prototype`
2. 若构造函数的 prototype 是一个对象，那么 `newInstance` 的 `[[prototype]]` 改为指向该对象
3. 使用给定参数执行构造函数，并且构造函数中的所有 `this` 引用都指向 `newInstance`
4. 如果构造函数返回非原始值，那么该返回值成为整个 `new` 表达式的结果；否则，`newInstance` 作为 `new` 表达式的结果返回

### 手写 new

```js
function myNew(constructor, ...args) {
  if (typeof constructor !== 'function') {
    console.error('Type Error');
    return;
  }
  const newInstance = Object.create(constructor.prototype);
  const result = constructor.apply(newInstance, args);
  if (typeof result === 'object' || typeof result === 'function') {
    return result;
  }
  return newInstance;
}
```
